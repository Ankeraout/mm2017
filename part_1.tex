\chapter{Systèmes cryptographiques et algorithmes de chiffrement}
	\section{Algorithmes symétriques et asymétriques}
		\subsection{Algorithme de chiffrement symétrique}
			Un algorithme de chiffrement est dit symétrique si un message chiffré avec cet algorithme peut être déchiffré en utilisant la clé qui a servi à le chiffrer. En général, le niveau de sécurité qu'offrent les algorithmes de ce type dépend de la complexité de la clé. C'est le type de chiffrement qui est utilisé la plupart du temps lorsqu'un client communique avec un serveur, car les algorithmes de chiffrement symétriques ont la particularité d'être - pour la plupart - rapides et efficaces. La grosse faiblesse de ces algorithmes est le fait que les deux parties communicantes doivent connaître la clé. Cela implique un échange de clés au départ de la communication. Pour cela, en pratique, un algorithme de chiffrement asymétrique est utilisé afin que personne d'autre que les deux parties communicantes ne puisse connaître la clé.
		\subsection{Algorithme de chiffrement asymétrique}
			Un algorithme de chiffrement est dit asymétrique si la clé ayant servi à chiffrer un message en utilisant cet algorithme n'est pas la même que la clé qui servira à le déchiffrer plus tard. En pratique, les deux parties s'échangent leurs clés publiques, mais conservent leurs clés privées. Les clés publiques servent à chiffrer les messages, et les clés privées servent à déchiffrer les messages. Ces algorithmes sont souvent lourds car ils impliquent la manipulation de nombres entiers très grands, ce qui se révèle être très coûteux en terme de temps processeur. C'est pour cela qu'en pratique, ces algorithmes sont utilisés pour échanger des clés de chiffrement pour des algorithmes de chiffrement symétriques, qui sont beaucoup plus rapides.
		\subsection{Algorithme de hachage}
			Les algorithmes dit de hachage ne sont pas des algorithmes de chiffrement à proprement parler, mais plutôt des algorithmes de cryptage, c'est-à-dire que le but d'un algorithme de hachage n'est pas de sécuriser la transmission d'un message, mais plutôt de rendre un message irrécupérable, mais d'être capable de l'identifier par sa signature. Nous pouvons ici prendre l'exemple de l'algorithme MD5, qui sert la plupart du temps à confirmer qu'un fichier téléchargé est complet et qu'il n'a pas subi d'erreurs de transmission. Pour cela, on compare la signature du fichier obtenue par l'algorithme MD5 du serveur et du client. Si les deux signatures sont égales, alors on peut affirmer qu'un fichier a une probabilité très grande de ne pas avoir subi d'erreurs. Ce genre d'algorithme peut aussi être utilisé afin de cacher des mots de passe dans une base de données. En sauvegardant uniquement le résultat de la fonction de hachage dans la base de données, on est capable de déterminer si le mot de passe entré est le bon ou pas, en comparant la signature enregistrée à la signature du mot de passe entré.
	\section{Système de Vigenère}
		\subsection{Définition}
			Le système de Vigenère est une méthode de chiffrement ayant une clé de longueur variable, inférieure ou égale à celle du message à transmettre. Lorsqu'on parle de système de Vigenère, on pense à l'utiliser dans le cadre de l'alphabet français, qui ne comporte que 26 caractères, mais il est possible d'étendre cet algorithme pour utiliser toutes les valeurs possibles de l'ASCII, ou même de l'Unicode.
		\subsection{Algorithme}
			Cet algorithme de chiffrement est réputé pour être très simple à mettre en \oe{uvre.}, et efficace à l'exécution, car le temps que prendra cet algorithme à chiffrer un caractère ne dépend ni de la longueur de la clé, ni de celle du message. La courbe représentant le temps que prendrait le chiffrement d'un message en fonction du nombre de caractères serait donc une droite, ce qui montre que cet algorithme est d'une complexité linéaire de l'ordre de O(n) où n est la longueur du message à chiffrer.\\
			Pour chiffrer un message en utilisant le système de Vigenère, il faut considérer qu'un message de longueur n est formé de caractères ayant des indices variant entre 0 et n - 1 dans un tableau. On considère la clé de la même façon. On obtient le caractère du message chiffré à l'indice i, noté C\lbrack{i}\rbrack, de la manière suivante :\linebreak
			\\
			C\lbrack{i}\rbrack = (M\lbrack{i}\rbrack + K\lbrack{i \% l}\rbrack) \% j\\
			\\
			où M\lbrack{i}\rbrack est le caractère à l'indice i du message initial M (on rappelle que l'indice varie entre 0 et n - 1), l est la longueur de la clé de chiffrement, K\lbrack{i \% l}\rbrack est le caractère de la clé de chiffrement à l'indice i modulo l, et j est le nombre de caractères codables dans le message initial. Dans le cadre de cette formule, on définit également l'opérateur \% comme l'opérateur renvoyant le reste de la division euclidienne de la partie gauche par la partie droite.\\
			L'opération peut être inversée pour obtenir le message initial à partir du message chiffré C et de la clé de chiffrement K, en utilisant la formule suivante :\\
			\\
			M\lbrack{i}\rbrack = (C\lbrack{i}\rbrack - K\lbrack{i}\rbrack + j) \% j
		\subsection{Niveau de sécurité}
			Dans le cas où la clé de chiffrement est de taille supérieure (inutile) ou égale à la longueur du message, et ne contient pas de répétitions, cet algorithme est réputé pour chiffrer des données de manière inviolable, c'est-à-dire qu'il est impossible de retrouver les données d'origine si on n'a aucune information sur ces dernières, car les données obtenues ressembleront à des données purement aléatoires. En pratique, cette méthode de chiffrement est employée avec une clé de taille inférieure à la taille du message. Dans ce cas-là, il est possible de pratiquer une cryptanalyse si l'on connaît la nature des données initiales. Pour plus d'informations, se référer à la partie sur la cryptanalyse du système de Vigenère.
		\subsection{Cas d'utilisation}
	\section{Système de César}
	\section{Système de substitution}
	\section{Algorithme RSA}